<?php
/**
 * Created by PhpStorm.
 * User: lidanyang
 * Date: 16/6/15
 * Time: 上午11:03
 */

namespace server;

use api\Api;
use api\cache\Cache;
use api\cache\FileCache;
use base\async\AsyncRedis;
use base\cache\Redis;
use base\model\Pool;
use sdk\config\Config;
use base\Enterance;
use base\log\Log;
use base\server\adapter\BaseCallback;
use GuzzleHttp\Promise\Promise;
use lib\Json;

class HttpServer extends BaseCallback
{
    /**
     * @var \swoole_server
     */
    public static $server;

    public function onWorkerStart($server, $workerId)
    {
        parent::onWorkerStart($server, $workerId);
        Config::load(Enterance::$rootPath . '/config');

        if($server->taskworker) {

        } else {
            Pool::getInstance()->init();
            AsyncRedis::getInstance()->connect(new Promise());
        }
    }
    
    public function onWorkerStop($server, $workerId)
    {
        parent::onWorkerStop($server, $workerId);

    }

    public function onShutDown()
    {
        parent::onShutDown(); // TODO: Change the autogenerated stub
        FileCache::getInstance()->unloadCache();
    }

    public function onRequest(\swoole_http_request $request, \swoole_http_response $response)
    {
        do{
            if( $request->server['path_info'] == '/playurl')
            {
                if( !isset($request->get) )
                {
                    Log::INFO('Error' , "Access 200: no get");
                    $response->status(200);
                    $response->end("");
                    break;
                }
                $result = Api::playurl($request, $response);
                if($result != -1)
                {
                    $data['request'] = $request->get;
                    $data['header'] = $request->header;
                    $data['result'] = $result;
                    Log::INFO('Access' , Json::json_encode($data));
                    if(empty($result) || $result === false )
                    {
                        $response->status(502);
                        $response->end("");
                        break;
                    }
                    $response->end($result? $result : "");
                }
            }
        } while(false);
        return;
    }

    public function onTask(\swoole_server $server, $task_id, $from_id, $data)
    {
        static $task_queue;
        if (!$task_queue) {
            $task_queue = array();
        }
        if (!isset($task_queue[$data])) {
            $task_queue[$data] = 3;
        } else {
            $task_queue[$data] += 3;
        }
        if (!isset($task_queue["req_count"])) {
            $task_queue["req_count"] = 0;
        } else {
            $task_queue["req_count"] += 1;
        }
        echo "task_queue length ".count($task_queue)." \n";

        $max_commit_redis_size = intval(Config::getField('bili', 'max_commit_redis_size'));
        if ($max_commit_redis_size <= 0) {
            $max_commit_redis_size = 5000;
        }
        if ($task_queue["req_count"] > $max_commit_redis_size) {
            $s_time = time();
            try {
                $redis = Redis::getInstance()->getConnection();
                $pipe = $redis->multi(\Redis::PIPELINE);
                foreach ($task_queue  as $k => $v) {
                    $pipe->incrBy($k, $v);
                }
                $pipe->exec();
            } catch (\RedisException $e) {
                Redis::getInstance()->connect();
                echo 'Caught exception: '.$e->getMessage()."";
            } finally {
                $task_queue = null;
                $task_queue = array();
            }
            $e_time = time();
            echo "stime :".$s_time." etime :".$e_time." cost time :".($e_time - $s_time)." \n";
        }
        return;
    }

    public function onFinish()
    {

    }

    public function setServer($server)
    {
        HttpServer::$server = $server;
    }

    public function onPipeMessage(\swoole_server $server, $from_worker_id, $message)
    {
        $data = json_decode($message, true);
        //var_dump($data);
        switch($data['id'])
        {
            case Cache::TYPE_DISPATCH_SERVER:
            {
                Cache::getInstance()->setDispatchServers($data['data']);
                break;
            }
            case Cache::TYPE_SERVER_LOAD:
            {
                Cache::getInstance()->setServerLoads($data['data']);
                break;
            }
            case Cache::TYPE_DISPATCH_ZONE:
            {
                Cache::getInstance()->setDispatchZoneGroups($data['data']);
                break;
            }
        }
    }

    public function beforeStart(\swoole_server $server)
    {
        // 添加工作进程,刷新缓存
        $process = new \swoole_process(function(\swoole_process $worker) use ($server){
            $worker->name(Config::get('project_name') . " cache process");
            Cache::getInstance()->setSocket($server);

            Pool::getInstance()->init(function(){
                Cache::getInstance()->refresh_sec();
            }, 2);

            swoole_timer_tick(10000, function(){
                Cache::getInstance()->refresh_sec();
            });
        }, false, false);

        $server->addProcess($process);
    }
}